Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    ARROW
    AT
    BACKSLASH
    BREAK
    DECREMENT
    DIVIDEASSIGN
    DOT
    DOUBLEQUOTE
    EQUAL
    GREATERTHAN
    GREATERTHANEQUAL
    HASH
    INCREMENT
    INPUT
    LESSTHAN
    LESSTHANEQUAL
    MINUSASSIGN
    MODASSIGN
    NEW
    NOTEQUAL
    NULL
    PARAMS
    PIPE
    PLUSASSIGN
    POW
    RETURN
    SLASH
    TIMESASSIGN

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> stmt stmt_list
Rule 3     stmt_list -> empty
Rule 4     stmt -> class_declaration
Rule 5     stmt -> fun_declaration
Rule 6     stmt -> import_declaration
Rule 7     stmt -> assignment
Rule 8     stmt -> variable_declaration
Rule 9     stmt -> print_stmt
Rule 10    stmt -> control_structure
Rule 11    stmt -> empty
Rule 12    class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE
Rule 13    fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
Rule 14    params -> general_type IDENTIFIER COMMA params
Rule 15    params -> general_type IDENTIFIER
Rule 16    params -> empty
Rule 17    import_declaration -> IMPORT STRING_LITERAL
Rule 18    variable_declaration -> general_type IDENTIFIER SEMICOLON
Rule 19    variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
Rule 20    variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON
Rule 21    assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON
Rule 22    assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
Rule 23    assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
Rule 24    print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON
Rule 25    control_structure -> if_stmt
Rule 26    control_structure -> for_stmt
Rule 27    control_structure -> while_stmt
Rule 28    control_structure -> switch_stmt
Rule 29    if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
Rule 30    if_stmt -> expression QUESTION expression COLON expression SEMICOLON
Rule 31    for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
Rule 32    while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
Rule 33    switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
Rule 34    case_stmts -> CASE expression COLON stmt_list case_stmts
Rule 35    case_stmts -> empty
Rule 36    default_stmt -> DEFAULT COLON stmt_list
Rule 37    default_stmt -> empty
Rule 38    expression -> expression PLUS expression
Rule 39    expression -> expression MINUS expression
Rule 40    expression -> expression MULTIPLY expression
Rule 41    expression -> expression DIVIDE expression
Rule 42    expression -> expression MODULUS expression
Rule 43    expression -> expression AND expression
Rule 44    expression -> expression OR expression
Rule 45    expression -> NOT expression
Rule 46    expression -> LPAREN expression RPAREN
Rule 47    expression -> IDENTIFIER
Rule 48    expression -> digit
Rule 49    expression -> STRING_LITERAL
Rule 50    expression -> boolean
Rule 51    expression -> IDENTIFIER LBRACKET expression RBRACKET
Rule 52    expression -> IDENTIFIER LBRACE expression RBRACE
Rule 53    digit -> NUMBER
Rule 54    boolean -> TRUE
Rule 55    boolean -> FALSE
Rule 56    type -> general_type
Rule 57    type -> array_type
Rule 58    type -> list_type
Rule 59    general_type -> INT
Rule 60    general_type -> FLOAT
Rule 61    general_type -> DOUBLE
Rule 62    general_type -> STRING
Rule 63    general_type -> BOOLEAN
Rule 64    general_type -> IDENTIFIER
Rule 65    array_type -> INTARRAY
Rule 66    array_type -> FLOATARRAY
Rule 67    array_type -> STRINGARRAY
Rule 68    array_type -> DOUBLEARRAY
Rule 69    list_type -> INTLIST
Rule 70    list_type -> FLOATLIST
Rule 71    list_type -> STRINGLIST
Rule 72    list_type -> DOUBLELIST
Rule 73    empty -> <empty>

Terminals, with rules where they appear

AND                  : 43
APOSTROPHE           : 
ARROW                : 
ASSIGN               : 21 22 23
AT                   : 
BACKSLASH            : 
BOOLEAN              : 63
BREAK                : 
CASE                 : 34
CLASS                : 12
COLON                : 30 34 36
COMMA                : 14
DECREMENT            : 
DEFAULT              : 36
DIVIDE               : 41
DIVIDEASSIGN         : 
DOT                  : 
DOUBLE               : 61
DOUBLEARRAY          : 68
DOUBLELIST           : 72
DOUBLEQUOTE          : 
ELSE                 : 29
EQUAL                : 
FALSE                : 55
FLOAT                : 60
FLOATARRAY           : 66
FLOATLIST            : 70
FOR                  : 31
FUN                  : 13
GREATERTHAN          : 
GREATERTHANEQUAL     : 
HASH                 : 
IDENTIFIER           : 12 13 14 15 18 19 20 21 22 23 47 51 52 64
IF                   : 29
IMPORT               : 17
INCREMENT            : 
INPUT                : 
INT                  : 59
INTARRAY             : 65
INTLIST              : 69
LBRACE               : 12 13 20 23 29 29 31 32 33 52
LBRACKET             : 19 22 51
LESSTHAN             : 
LESSTHANEQUAL        : 
LPAREN               : 13 24 29 31 32 33 46
MINUS                : 39
MINUSASSIGN          : 
MODASSIGN            : 
MODULUS              : 42
MULTIPLY             : 40
NEW                  : 
NOT                  : 45
NOTEQUAL             : 
NULL                 : 
NUMBER               : 53
OR                   : 44
PARAMS               : 
PIPE                 : 
PLUS                 : 38
PLUSASSIGN           : 
POW                  : 
PRINT                : 24
QUESTION             : 30
RBRACE               : 12 13 20 23 29 29 31 32 33 52
RBRACKET             : 19 22 51
RETURN               : 
RPAREN               : 13 24 29 31 32 33 46
SEMICOLON            : 18 19 20 21 22 23 24 30 31 31
SLASH                : 
STRING               : 62
STRINGARRAY          : 67
STRINGLIST           : 71
STRING_LITERAL       : 17 49
SWITCH               : 33
TIMESASSIGN          : 
TRUE                 : 54
WHILE                : 32
error                : 

Nonterminals, with rules where they appear

array_type           : 20 57
assignment           : 7 31
boolean              : 50
case_stmts           : 33 34
class_declaration    : 4
control_structure    : 10
default_stmt         : 33
digit                : 48
empty                : 3 11 16 35 37
expression           : 21 22 22 23 23 24 29 30 30 30 31 31 32 33 34 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 46 51 52
for_stmt             : 26
fun_declaration      : 5
general_type         : 14 15 18 21 56
if_stmt              : 25
import_declaration   : 6
list_type            : 19 58
params               : 13 14
print_stmt           : 9
program              : 0
stmt                 : 2
stmt_list            : 1 2 12 13 29 29 31 32 34 36
switch_stmt          : 28
type                 : 22 23
variable_declaration : 8
while_stmt           : 27

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    $end            reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    expression                     shift and go to state 19
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .

    $end            reduce using rule 1 (program -> stmt_list .)


state 3

    (2) stmt_list -> stmt . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    $end            reduce using rule 73 (empty -> .)
    RBRACE          reduce using rule 73 (empty -> .)
    CASE            reduce using rule 73 (empty -> .)
    DEFAULT         reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    stmt                           shift and go to state 3
    stmt_list                      shift and go to state 51
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    expression                     shift and go to state 19
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 4

    (3) stmt_list -> empty .
    (11) stmt -> empty .

  ! reduce/reduce conflict for $end resolved using rule 3 (stmt_list -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 3 (stmt_list -> empty .)
  ! reduce/reduce conflict for CASE resolved using rule 3 (stmt_list -> empty .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 3 (stmt_list -> empty .)
    $end            reduce using rule 3 (stmt_list -> empty .)
    RBRACE          reduce using rule 3 (stmt_list -> empty .)
    CASE            reduce using rule 3 (stmt_list -> empty .)
    DEFAULT         reduce using rule 3 (stmt_list -> empty .)
    CLASS           reduce using rule 11 (stmt -> empty .)
    FUN             reduce using rule 11 (stmt -> empty .)
    IMPORT          reduce using rule 11 (stmt -> empty .)
    PRINT           reduce using rule 11 (stmt -> empty .)
    INT             reduce using rule 11 (stmt -> empty .)
    FLOAT           reduce using rule 11 (stmt -> empty .)
    DOUBLE          reduce using rule 11 (stmt -> empty .)
    STRING          reduce using rule 11 (stmt -> empty .)
    BOOLEAN         reduce using rule 11 (stmt -> empty .)
    IDENTIFIER      reduce using rule 11 (stmt -> empty .)
    INTLIST         reduce using rule 11 (stmt -> empty .)
    FLOATLIST       reduce using rule 11 (stmt -> empty .)
    STRINGLIST      reduce using rule 11 (stmt -> empty .)
    DOUBLELIST      reduce using rule 11 (stmt -> empty .)
    INTARRAY        reduce using rule 11 (stmt -> empty .)
    FLOATARRAY      reduce using rule 11 (stmt -> empty .)
    STRINGARRAY     reduce using rule 11 (stmt -> empty .)
    DOUBLEARRAY     reduce using rule 11 (stmt -> empty .)
    IF              reduce using rule 11 (stmt -> empty .)
    FOR             reduce using rule 11 (stmt -> empty .)
    WHILE           reduce using rule 11 (stmt -> empty .)
    SWITCH          reduce using rule 11 (stmt -> empty .)
    NOT             reduce using rule 11 (stmt -> empty .)
    LPAREN          reduce using rule 11 (stmt -> empty .)
    STRING_LITERAL  reduce using rule 11 (stmt -> empty .)
    NUMBER          reduce using rule 11 (stmt -> empty .)
    TRUE            reduce using rule 11 (stmt -> empty .)
    FALSE           reduce using rule 11 (stmt -> empty .)

  ! $end            [ reduce using rule 11 (stmt -> empty .) ]
  ! RBRACE          [ reduce using rule 11 (stmt -> empty .) ]
  ! CASE            [ reduce using rule 11 (stmt -> empty .) ]
  ! DEFAULT         [ reduce using rule 11 (stmt -> empty .) ]


state 5

    (4) stmt -> class_declaration .

    CLASS           reduce using rule 4 (stmt -> class_declaration .)
    FUN             reduce using rule 4 (stmt -> class_declaration .)
    IMPORT          reduce using rule 4 (stmt -> class_declaration .)
    PRINT           reduce using rule 4 (stmt -> class_declaration .)
    INT             reduce using rule 4 (stmt -> class_declaration .)
    FLOAT           reduce using rule 4 (stmt -> class_declaration .)
    DOUBLE          reduce using rule 4 (stmt -> class_declaration .)
    STRING          reduce using rule 4 (stmt -> class_declaration .)
    BOOLEAN         reduce using rule 4 (stmt -> class_declaration .)
    IDENTIFIER      reduce using rule 4 (stmt -> class_declaration .)
    INTLIST         reduce using rule 4 (stmt -> class_declaration .)
    FLOATLIST       reduce using rule 4 (stmt -> class_declaration .)
    STRINGLIST      reduce using rule 4 (stmt -> class_declaration .)
    DOUBLELIST      reduce using rule 4 (stmt -> class_declaration .)
    INTARRAY        reduce using rule 4 (stmt -> class_declaration .)
    FLOATARRAY      reduce using rule 4 (stmt -> class_declaration .)
    STRINGARRAY     reduce using rule 4 (stmt -> class_declaration .)
    DOUBLEARRAY     reduce using rule 4 (stmt -> class_declaration .)
    IF              reduce using rule 4 (stmt -> class_declaration .)
    FOR             reduce using rule 4 (stmt -> class_declaration .)
    WHILE           reduce using rule 4 (stmt -> class_declaration .)
    SWITCH          reduce using rule 4 (stmt -> class_declaration .)
    NOT             reduce using rule 4 (stmt -> class_declaration .)
    LPAREN          reduce using rule 4 (stmt -> class_declaration .)
    STRING_LITERAL  reduce using rule 4 (stmt -> class_declaration .)
    NUMBER          reduce using rule 4 (stmt -> class_declaration .)
    TRUE            reduce using rule 4 (stmt -> class_declaration .)
    FALSE           reduce using rule 4 (stmt -> class_declaration .)
    $end            reduce using rule 4 (stmt -> class_declaration .)
    RBRACE          reduce using rule 4 (stmt -> class_declaration .)
    CASE            reduce using rule 4 (stmt -> class_declaration .)
    DEFAULT         reduce using rule 4 (stmt -> class_declaration .)


state 6

    (5) stmt -> fun_declaration .

    CLASS           reduce using rule 5 (stmt -> fun_declaration .)
    FUN             reduce using rule 5 (stmt -> fun_declaration .)
    IMPORT          reduce using rule 5 (stmt -> fun_declaration .)
    PRINT           reduce using rule 5 (stmt -> fun_declaration .)
    INT             reduce using rule 5 (stmt -> fun_declaration .)
    FLOAT           reduce using rule 5 (stmt -> fun_declaration .)
    DOUBLE          reduce using rule 5 (stmt -> fun_declaration .)
    STRING          reduce using rule 5 (stmt -> fun_declaration .)
    BOOLEAN         reduce using rule 5 (stmt -> fun_declaration .)
    IDENTIFIER      reduce using rule 5 (stmt -> fun_declaration .)
    INTLIST         reduce using rule 5 (stmt -> fun_declaration .)
    FLOATLIST       reduce using rule 5 (stmt -> fun_declaration .)
    STRINGLIST      reduce using rule 5 (stmt -> fun_declaration .)
    DOUBLELIST      reduce using rule 5 (stmt -> fun_declaration .)
    INTARRAY        reduce using rule 5 (stmt -> fun_declaration .)
    FLOATARRAY      reduce using rule 5 (stmt -> fun_declaration .)
    STRINGARRAY     reduce using rule 5 (stmt -> fun_declaration .)
    DOUBLEARRAY     reduce using rule 5 (stmt -> fun_declaration .)
    IF              reduce using rule 5 (stmt -> fun_declaration .)
    FOR             reduce using rule 5 (stmt -> fun_declaration .)
    WHILE           reduce using rule 5 (stmt -> fun_declaration .)
    SWITCH          reduce using rule 5 (stmt -> fun_declaration .)
    NOT             reduce using rule 5 (stmt -> fun_declaration .)
    LPAREN          reduce using rule 5 (stmt -> fun_declaration .)
    STRING_LITERAL  reduce using rule 5 (stmt -> fun_declaration .)
    NUMBER          reduce using rule 5 (stmt -> fun_declaration .)
    TRUE            reduce using rule 5 (stmt -> fun_declaration .)
    FALSE           reduce using rule 5 (stmt -> fun_declaration .)
    $end            reduce using rule 5 (stmt -> fun_declaration .)
    RBRACE          reduce using rule 5 (stmt -> fun_declaration .)
    CASE            reduce using rule 5 (stmt -> fun_declaration .)
    DEFAULT         reduce using rule 5 (stmt -> fun_declaration .)


state 7

    (6) stmt -> import_declaration .

    CLASS           reduce using rule 6 (stmt -> import_declaration .)
    FUN             reduce using rule 6 (stmt -> import_declaration .)
    IMPORT          reduce using rule 6 (stmt -> import_declaration .)
    PRINT           reduce using rule 6 (stmt -> import_declaration .)
    INT             reduce using rule 6 (stmt -> import_declaration .)
    FLOAT           reduce using rule 6 (stmt -> import_declaration .)
    DOUBLE          reduce using rule 6 (stmt -> import_declaration .)
    STRING          reduce using rule 6 (stmt -> import_declaration .)
    BOOLEAN         reduce using rule 6 (stmt -> import_declaration .)
    IDENTIFIER      reduce using rule 6 (stmt -> import_declaration .)
    INTLIST         reduce using rule 6 (stmt -> import_declaration .)
    FLOATLIST       reduce using rule 6 (stmt -> import_declaration .)
    STRINGLIST      reduce using rule 6 (stmt -> import_declaration .)
    DOUBLELIST      reduce using rule 6 (stmt -> import_declaration .)
    INTARRAY        reduce using rule 6 (stmt -> import_declaration .)
    FLOATARRAY      reduce using rule 6 (stmt -> import_declaration .)
    STRINGARRAY     reduce using rule 6 (stmt -> import_declaration .)
    DOUBLEARRAY     reduce using rule 6 (stmt -> import_declaration .)
    IF              reduce using rule 6 (stmt -> import_declaration .)
    FOR             reduce using rule 6 (stmt -> import_declaration .)
    WHILE           reduce using rule 6 (stmt -> import_declaration .)
    SWITCH          reduce using rule 6 (stmt -> import_declaration .)
    NOT             reduce using rule 6 (stmt -> import_declaration .)
    LPAREN          reduce using rule 6 (stmt -> import_declaration .)
    STRING_LITERAL  reduce using rule 6 (stmt -> import_declaration .)
    NUMBER          reduce using rule 6 (stmt -> import_declaration .)
    TRUE            reduce using rule 6 (stmt -> import_declaration .)
    FALSE           reduce using rule 6 (stmt -> import_declaration .)
    $end            reduce using rule 6 (stmt -> import_declaration .)
    RBRACE          reduce using rule 6 (stmt -> import_declaration .)
    CASE            reduce using rule 6 (stmt -> import_declaration .)
    DEFAULT         reduce using rule 6 (stmt -> import_declaration .)


state 8

    (7) stmt -> assignment .

    CLASS           reduce using rule 7 (stmt -> assignment .)
    FUN             reduce using rule 7 (stmt -> assignment .)
    IMPORT          reduce using rule 7 (stmt -> assignment .)
    PRINT           reduce using rule 7 (stmt -> assignment .)
    INT             reduce using rule 7 (stmt -> assignment .)
    FLOAT           reduce using rule 7 (stmt -> assignment .)
    DOUBLE          reduce using rule 7 (stmt -> assignment .)
    STRING          reduce using rule 7 (stmt -> assignment .)
    BOOLEAN         reduce using rule 7 (stmt -> assignment .)
    IDENTIFIER      reduce using rule 7 (stmt -> assignment .)
    INTLIST         reduce using rule 7 (stmt -> assignment .)
    FLOATLIST       reduce using rule 7 (stmt -> assignment .)
    STRINGLIST      reduce using rule 7 (stmt -> assignment .)
    DOUBLELIST      reduce using rule 7 (stmt -> assignment .)
    INTARRAY        reduce using rule 7 (stmt -> assignment .)
    FLOATARRAY      reduce using rule 7 (stmt -> assignment .)
    STRINGARRAY     reduce using rule 7 (stmt -> assignment .)
    DOUBLEARRAY     reduce using rule 7 (stmt -> assignment .)
    IF              reduce using rule 7 (stmt -> assignment .)
    FOR             reduce using rule 7 (stmt -> assignment .)
    WHILE           reduce using rule 7 (stmt -> assignment .)
    SWITCH          reduce using rule 7 (stmt -> assignment .)
    NOT             reduce using rule 7 (stmt -> assignment .)
    LPAREN          reduce using rule 7 (stmt -> assignment .)
    STRING_LITERAL  reduce using rule 7 (stmt -> assignment .)
    NUMBER          reduce using rule 7 (stmt -> assignment .)
    TRUE            reduce using rule 7 (stmt -> assignment .)
    FALSE           reduce using rule 7 (stmt -> assignment .)
    $end            reduce using rule 7 (stmt -> assignment .)
    RBRACE          reduce using rule 7 (stmt -> assignment .)
    CASE            reduce using rule 7 (stmt -> assignment .)
    DEFAULT         reduce using rule 7 (stmt -> assignment .)


state 9

    (8) stmt -> variable_declaration .

    CLASS           reduce using rule 8 (stmt -> variable_declaration .)
    FUN             reduce using rule 8 (stmt -> variable_declaration .)
    IMPORT          reduce using rule 8 (stmt -> variable_declaration .)
    PRINT           reduce using rule 8 (stmt -> variable_declaration .)
    INT             reduce using rule 8 (stmt -> variable_declaration .)
    FLOAT           reduce using rule 8 (stmt -> variable_declaration .)
    DOUBLE          reduce using rule 8 (stmt -> variable_declaration .)
    STRING          reduce using rule 8 (stmt -> variable_declaration .)
    BOOLEAN         reduce using rule 8 (stmt -> variable_declaration .)
    IDENTIFIER      reduce using rule 8 (stmt -> variable_declaration .)
    INTLIST         reduce using rule 8 (stmt -> variable_declaration .)
    FLOATLIST       reduce using rule 8 (stmt -> variable_declaration .)
    STRINGLIST      reduce using rule 8 (stmt -> variable_declaration .)
    DOUBLELIST      reduce using rule 8 (stmt -> variable_declaration .)
    INTARRAY        reduce using rule 8 (stmt -> variable_declaration .)
    FLOATARRAY      reduce using rule 8 (stmt -> variable_declaration .)
    STRINGARRAY     reduce using rule 8 (stmt -> variable_declaration .)
    DOUBLEARRAY     reduce using rule 8 (stmt -> variable_declaration .)
    IF              reduce using rule 8 (stmt -> variable_declaration .)
    FOR             reduce using rule 8 (stmt -> variable_declaration .)
    WHILE           reduce using rule 8 (stmt -> variable_declaration .)
    SWITCH          reduce using rule 8 (stmt -> variable_declaration .)
    NOT             reduce using rule 8 (stmt -> variable_declaration .)
    LPAREN          reduce using rule 8 (stmt -> variable_declaration .)
    STRING_LITERAL  reduce using rule 8 (stmt -> variable_declaration .)
    NUMBER          reduce using rule 8 (stmt -> variable_declaration .)
    TRUE            reduce using rule 8 (stmt -> variable_declaration .)
    FALSE           reduce using rule 8 (stmt -> variable_declaration .)
    $end            reduce using rule 8 (stmt -> variable_declaration .)
    RBRACE          reduce using rule 8 (stmt -> variable_declaration .)
    CASE            reduce using rule 8 (stmt -> variable_declaration .)
    DEFAULT         reduce using rule 8 (stmt -> variable_declaration .)


state 10

    (9) stmt -> print_stmt .

    CLASS           reduce using rule 9 (stmt -> print_stmt .)
    FUN             reduce using rule 9 (stmt -> print_stmt .)
    IMPORT          reduce using rule 9 (stmt -> print_stmt .)
    PRINT           reduce using rule 9 (stmt -> print_stmt .)
    INT             reduce using rule 9 (stmt -> print_stmt .)
    FLOAT           reduce using rule 9 (stmt -> print_stmt .)
    DOUBLE          reduce using rule 9 (stmt -> print_stmt .)
    STRING          reduce using rule 9 (stmt -> print_stmt .)
    BOOLEAN         reduce using rule 9 (stmt -> print_stmt .)
    IDENTIFIER      reduce using rule 9 (stmt -> print_stmt .)
    INTLIST         reduce using rule 9 (stmt -> print_stmt .)
    FLOATLIST       reduce using rule 9 (stmt -> print_stmt .)
    STRINGLIST      reduce using rule 9 (stmt -> print_stmt .)
    DOUBLELIST      reduce using rule 9 (stmt -> print_stmt .)
    INTARRAY        reduce using rule 9 (stmt -> print_stmt .)
    FLOATARRAY      reduce using rule 9 (stmt -> print_stmt .)
    STRINGARRAY     reduce using rule 9 (stmt -> print_stmt .)
    DOUBLEARRAY     reduce using rule 9 (stmt -> print_stmt .)
    IF              reduce using rule 9 (stmt -> print_stmt .)
    FOR             reduce using rule 9 (stmt -> print_stmt .)
    WHILE           reduce using rule 9 (stmt -> print_stmt .)
    SWITCH          reduce using rule 9 (stmt -> print_stmt .)
    NOT             reduce using rule 9 (stmt -> print_stmt .)
    LPAREN          reduce using rule 9 (stmt -> print_stmt .)
    STRING_LITERAL  reduce using rule 9 (stmt -> print_stmt .)
    NUMBER          reduce using rule 9 (stmt -> print_stmt .)
    TRUE            reduce using rule 9 (stmt -> print_stmt .)
    FALSE           reduce using rule 9 (stmt -> print_stmt .)
    $end            reduce using rule 9 (stmt -> print_stmt .)
    RBRACE          reduce using rule 9 (stmt -> print_stmt .)
    CASE            reduce using rule 9 (stmt -> print_stmt .)
    DEFAULT         reduce using rule 9 (stmt -> print_stmt .)


state 11

    (10) stmt -> control_structure .

    CLASS           reduce using rule 10 (stmt -> control_structure .)
    FUN             reduce using rule 10 (stmt -> control_structure .)
    IMPORT          reduce using rule 10 (stmt -> control_structure .)
    PRINT           reduce using rule 10 (stmt -> control_structure .)
    INT             reduce using rule 10 (stmt -> control_structure .)
    FLOAT           reduce using rule 10 (stmt -> control_structure .)
    DOUBLE          reduce using rule 10 (stmt -> control_structure .)
    STRING          reduce using rule 10 (stmt -> control_structure .)
    BOOLEAN         reduce using rule 10 (stmt -> control_structure .)
    IDENTIFIER      reduce using rule 10 (stmt -> control_structure .)
    INTLIST         reduce using rule 10 (stmt -> control_structure .)
    FLOATLIST       reduce using rule 10 (stmt -> control_structure .)
    STRINGLIST      reduce using rule 10 (stmt -> control_structure .)
    DOUBLELIST      reduce using rule 10 (stmt -> control_structure .)
    INTARRAY        reduce using rule 10 (stmt -> control_structure .)
    FLOATARRAY      reduce using rule 10 (stmt -> control_structure .)
    STRINGARRAY     reduce using rule 10 (stmt -> control_structure .)
    DOUBLEARRAY     reduce using rule 10 (stmt -> control_structure .)
    IF              reduce using rule 10 (stmt -> control_structure .)
    FOR             reduce using rule 10 (stmt -> control_structure .)
    WHILE           reduce using rule 10 (stmt -> control_structure .)
    SWITCH          reduce using rule 10 (stmt -> control_structure .)
    NOT             reduce using rule 10 (stmt -> control_structure .)
    LPAREN          reduce using rule 10 (stmt -> control_structure .)
    STRING_LITERAL  reduce using rule 10 (stmt -> control_structure .)
    NUMBER          reduce using rule 10 (stmt -> control_structure .)
    TRUE            reduce using rule 10 (stmt -> control_structure .)
    FALSE           reduce using rule 10 (stmt -> control_structure .)
    $end            reduce using rule 10 (stmt -> control_structure .)
    RBRACE          reduce using rule 10 (stmt -> control_structure .)
    CASE            reduce using rule 10 (stmt -> control_structure .)
    DEFAULT         reduce using rule 10 (stmt -> control_structure .)


state 12

    (12) class_declaration -> CLASS . IDENTIFIER LBRACE stmt_list RBRACE

    IDENTIFIER      shift and go to state 52


state 13

    (64) general_type -> IDENTIFIER .
    (47) expression -> IDENTIFIER .
    (51) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (52) expression -> IDENTIFIER . LBRACE expression RBRACE

    IDENTIFIER      reduce using rule 64 (general_type -> IDENTIFIER .)
    QUESTION        reduce using rule 47 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 47 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 47 (expression -> IDENTIFIER .)
    MULTIPLY        reduce using rule 47 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 47 (expression -> IDENTIFIER .)
    MODULUS         reduce using rule 47 (expression -> IDENTIFIER .)
    AND             reduce using rule 47 (expression -> IDENTIFIER .)
    OR              reduce using rule 47 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 53
    LBRACE          shift and go to state 54


state 14

    (13) fun_declaration -> FUN . IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE

    IDENTIFIER      shift and go to state 55


state 15

    (46) expression -> LPAREN . expression RPAREN
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 56
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 16

    (17) import_declaration -> IMPORT . STRING_LITERAL

    STRING_LITERAL  shift and go to state 58


state 17

    (49) expression -> STRING_LITERAL .

    QUESTION        reduce using rule 49 (expression -> STRING_LITERAL .)
    PLUS            reduce using rule 49 (expression -> STRING_LITERAL .)
    MINUS           reduce using rule 49 (expression -> STRING_LITERAL .)
    MULTIPLY        reduce using rule 49 (expression -> STRING_LITERAL .)
    DIVIDE          reduce using rule 49 (expression -> STRING_LITERAL .)
    MODULUS         reduce using rule 49 (expression -> STRING_LITERAL .)
    AND             reduce using rule 49 (expression -> STRING_LITERAL .)
    OR              reduce using rule 49 (expression -> STRING_LITERAL .)
    RPAREN          reduce using rule 49 (expression -> STRING_LITERAL .)
    RBRACKET        reduce using rule 49 (expression -> STRING_LITERAL .)
    RBRACE          reduce using rule 49 (expression -> STRING_LITERAL .)
    COLON           reduce using rule 49 (expression -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 49 (expression -> STRING_LITERAL .)


state 18

    (21) assignment -> general_type . IDENTIFIER ASSIGN expression SEMICOLON
    (18) variable_declaration -> general_type . IDENTIFIER SEMICOLON
    (56) type -> general_type .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 59

  ! IDENTIFIER      [ reduce using rule 56 (type -> general_type .) ]


state 19

    (30) if_stmt -> expression . QUESTION expression COLON expression SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    QUESTION        shift and go to state 60
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 20

    (22) assignment -> type . IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> type . IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON

    IDENTIFIER      shift and go to state 68


state 21

    (19) variable_declaration -> list_type . IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (58) type -> list_type .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 69

  ! IDENTIFIER      [ reduce using rule 58 (type -> list_type .) ]


state 22

    (20) variable_declaration -> array_type . IDENTIFIER LBRACE RBRACE SEMICOLON
    (57) type -> array_type .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 70

  ! IDENTIFIER      [ reduce using rule 57 (type -> array_type .) ]


state 23

    (24) print_stmt -> PRINT . LPAREN expression RPAREN SEMICOLON

    LPAREN          shift and go to state 71


state 24

    (25) control_structure -> if_stmt .

    CLASS           reduce using rule 25 (control_structure -> if_stmt .)
    FUN             reduce using rule 25 (control_structure -> if_stmt .)
    IMPORT          reduce using rule 25 (control_structure -> if_stmt .)
    PRINT           reduce using rule 25 (control_structure -> if_stmt .)
    INT             reduce using rule 25 (control_structure -> if_stmt .)
    FLOAT           reduce using rule 25 (control_structure -> if_stmt .)
    DOUBLE          reduce using rule 25 (control_structure -> if_stmt .)
    STRING          reduce using rule 25 (control_structure -> if_stmt .)
    BOOLEAN         reduce using rule 25 (control_structure -> if_stmt .)
    IDENTIFIER      reduce using rule 25 (control_structure -> if_stmt .)
    INTLIST         reduce using rule 25 (control_structure -> if_stmt .)
    FLOATLIST       reduce using rule 25 (control_structure -> if_stmt .)
    STRINGLIST      reduce using rule 25 (control_structure -> if_stmt .)
    DOUBLELIST      reduce using rule 25 (control_structure -> if_stmt .)
    INTARRAY        reduce using rule 25 (control_structure -> if_stmt .)
    FLOATARRAY      reduce using rule 25 (control_structure -> if_stmt .)
    STRINGARRAY     reduce using rule 25 (control_structure -> if_stmt .)
    DOUBLEARRAY     reduce using rule 25 (control_structure -> if_stmt .)
    IF              reduce using rule 25 (control_structure -> if_stmt .)
    FOR             reduce using rule 25 (control_structure -> if_stmt .)
    WHILE           reduce using rule 25 (control_structure -> if_stmt .)
    SWITCH          reduce using rule 25 (control_structure -> if_stmt .)
    NOT             reduce using rule 25 (control_structure -> if_stmt .)
    LPAREN          reduce using rule 25 (control_structure -> if_stmt .)
    STRING_LITERAL  reduce using rule 25 (control_structure -> if_stmt .)
    NUMBER          reduce using rule 25 (control_structure -> if_stmt .)
    TRUE            reduce using rule 25 (control_structure -> if_stmt .)
    FALSE           reduce using rule 25 (control_structure -> if_stmt .)
    $end            reduce using rule 25 (control_structure -> if_stmt .)
    RBRACE          reduce using rule 25 (control_structure -> if_stmt .)
    CASE            reduce using rule 25 (control_structure -> if_stmt .)
    DEFAULT         reduce using rule 25 (control_structure -> if_stmt .)


state 25

    (26) control_structure -> for_stmt .

    CLASS           reduce using rule 26 (control_structure -> for_stmt .)
    FUN             reduce using rule 26 (control_structure -> for_stmt .)
    IMPORT          reduce using rule 26 (control_structure -> for_stmt .)
    PRINT           reduce using rule 26 (control_structure -> for_stmt .)
    INT             reduce using rule 26 (control_structure -> for_stmt .)
    FLOAT           reduce using rule 26 (control_structure -> for_stmt .)
    DOUBLE          reduce using rule 26 (control_structure -> for_stmt .)
    STRING          reduce using rule 26 (control_structure -> for_stmt .)
    BOOLEAN         reduce using rule 26 (control_structure -> for_stmt .)
    IDENTIFIER      reduce using rule 26 (control_structure -> for_stmt .)
    INTLIST         reduce using rule 26 (control_structure -> for_stmt .)
    FLOATLIST       reduce using rule 26 (control_structure -> for_stmt .)
    STRINGLIST      reduce using rule 26 (control_structure -> for_stmt .)
    DOUBLELIST      reduce using rule 26 (control_structure -> for_stmt .)
    INTARRAY        reduce using rule 26 (control_structure -> for_stmt .)
    FLOATARRAY      reduce using rule 26 (control_structure -> for_stmt .)
    STRINGARRAY     reduce using rule 26 (control_structure -> for_stmt .)
    DOUBLEARRAY     reduce using rule 26 (control_structure -> for_stmt .)
    IF              reduce using rule 26 (control_structure -> for_stmt .)
    FOR             reduce using rule 26 (control_structure -> for_stmt .)
    WHILE           reduce using rule 26 (control_structure -> for_stmt .)
    SWITCH          reduce using rule 26 (control_structure -> for_stmt .)
    NOT             reduce using rule 26 (control_structure -> for_stmt .)
    LPAREN          reduce using rule 26 (control_structure -> for_stmt .)
    STRING_LITERAL  reduce using rule 26 (control_structure -> for_stmt .)
    NUMBER          reduce using rule 26 (control_structure -> for_stmt .)
    TRUE            reduce using rule 26 (control_structure -> for_stmt .)
    FALSE           reduce using rule 26 (control_structure -> for_stmt .)
    $end            reduce using rule 26 (control_structure -> for_stmt .)
    RBRACE          reduce using rule 26 (control_structure -> for_stmt .)
    CASE            reduce using rule 26 (control_structure -> for_stmt .)
    DEFAULT         reduce using rule 26 (control_structure -> for_stmt .)


state 26

    (27) control_structure -> while_stmt .

    CLASS           reduce using rule 27 (control_structure -> while_stmt .)
    FUN             reduce using rule 27 (control_structure -> while_stmt .)
    IMPORT          reduce using rule 27 (control_structure -> while_stmt .)
    PRINT           reduce using rule 27 (control_structure -> while_stmt .)
    INT             reduce using rule 27 (control_structure -> while_stmt .)
    FLOAT           reduce using rule 27 (control_structure -> while_stmt .)
    DOUBLE          reduce using rule 27 (control_structure -> while_stmt .)
    STRING          reduce using rule 27 (control_structure -> while_stmt .)
    BOOLEAN         reduce using rule 27 (control_structure -> while_stmt .)
    IDENTIFIER      reduce using rule 27 (control_structure -> while_stmt .)
    INTLIST         reduce using rule 27 (control_structure -> while_stmt .)
    FLOATLIST       reduce using rule 27 (control_structure -> while_stmt .)
    STRINGLIST      reduce using rule 27 (control_structure -> while_stmt .)
    DOUBLELIST      reduce using rule 27 (control_structure -> while_stmt .)
    INTARRAY        reduce using rule 27 (control_structure -> while_stmt .)
    FLOATARRAY      reduce using rule 27 (control_structure -> while_stmt .)
    STRINGARRAY     reduce using rule 27 (control_structure -> while_stmt .)
    DOUBLEARRAY     reduce using rule 27 (control_structure -> while_stmt .)
    IF              reduce using rule 27 (control_structure -> while_stmt .)
    FOR             reduce using rule 27 (control_structure -> while_stmt .)
    WHILE           reduce using rule 27 (control_structure -> while_stmt .)
    SWITCH          reduce using rule 27 (control_structure -> while_stmt .)
    NOT             reduce using rule 27 (control_structure -> while_stmt .)
    LPAREN          reduce using rule 27 (control_structure -> while_stmt .)
    STRING_LITERAL  reduce using rule 27 (control_structure -> while_stmt .)
    NUMBER          reduce using rule 27 (control_structure -> while_stmt .)
    TRUE            reduce using rule 27 (control_structure -> while_stmt .)
    FALSE           reduce using rule 27 (control_structure -> while_stmt .)
    $end            reduce using rule 27 (control_structure -> while_stmt .)
    RBRACE          reduce using rule 27 (control_structure -> while_stmt .)
    CASE            reduce using rule 27 (control_structure -> while_stmt .)
    DEFAULT         reduce using rule 27 (control_structure -> while_stmt .)


state 27

    (28) control_structure -> switch_stmt .

    CLASS           reduce using rule 28 (control_structure -> switch_stmt .)
    FUN             reduce using rule 28 (control_structure -> switch_stmt .)
    IMPORT          reduce using rule 28 (control_structure -> switch_stmt .)
    PRINT           reduce using rule 28 (control_structure -> switch_stmt .)
    INT             reduce using rule 28 (control_structure -> switch_stmt .)
    FLOAT           reduce using rule 28 (control_structure -> switch_stmt .)
    DOUBLE          reduce using rule 28 (control_structure -> switch_stmt .)
    STRING          reduce using rule 28 (control_structure -> switch_stmt .)
    BOOLEAN         reduce using rule 28 (control_structure -> switch_stmt .)
    IDENTIFIER      reduce using rule 28 (control_structure -> switch_stmt .)
    INTLIST         reduce using rule 28 (control_structure -> switch_stmt .)
    FLOATLIST       reduce using rule 28 (control_structure -> switch_stmt .)
    STRINGLIST      reduce using rule 28 (control_structure -> switch_stmt .)
    DOUBLELIST      reduce using rule 28 (control_structure -> switch_stmt .)
    INTARRAY        reduce using rule 28 (control_structure -> switch_stmt .)
    FLOATARRAY      reduce using rule 28 (control_structure -> switch_stmt .)
    STRINGARRAY     reduce using rule 28 (control_structure -> switch_stmt .)
    DOUBLEARRAY     reduce using rule 28 (control_structure -> switch_stmt .)
    IF              reduce using rule 28 (control_structure -> switch_stmt .)
    FOR             reduce using rule 28 (control_structure -> switch_stmt .)
    WHILE           reduce using rule 28 (control_structure -> switch_stmt .)
    SWITCH          reduce using rule 28 (control_structure -> switch_stmt .)
    NOT             reduce using rule 28 (control_structure -> switch_stmt .)
    LPAREN          reduce using rule 28 (control_structure -> switch_stmt .)
    STRING_LITERAL  reduce using rule 28 (control_structure -> switch_stmt .)
    NUMBER          reduce using rule 28 (control_structure -> switch_stmt .)
    TRUE            reduce using rule 28 (control_structure -> switch_stmt .)
    FALSE           reduce using rule 28 (control_structure -> switch_stmt .)
    $end            reduce using rule 28 (control_structure -> switch_stmt .)
    RBRACE          reduce using rule 28 (control_structure -> switch_stmt .)
    CASE            reduce using rule 28 (control_structure -> switch_stmt .)
    DEFAULT         reduce using rule 28 (control_structure -> switch_stmt .)


state 28

    (59) general_type -> INT .

    IDENTIFIER      reduce using rule 59 (general_type -> INT .)


state 29

    (60) general_type -> FLOAT .

    IDENTIFIER      reduce using rule 60 (general_type -> FLOAT .)


state 30

    (61) general_type -> DOUBLE .

    IDENTIFIER      reduce using rule 61 (general_type -> DOUBLE .)


state 31

    (62) general_type -> STRING .

    IDENTIFIER      reduce using rule 62 (general_type -> STRING .)


state 32

    (63) general_type -> BOOLEAN .

    IDENTIFIER      reduce using rule 63 (general_type -> BOOLEAN .)


state 33

    (69) list_type -> INTLIST .

    IDENTIFIER      reduce using rule 69 (list_type -> INTLIST .)


state 34

    (70) list_type -> FLOATLIST .

    IDENTIFIER      reduce using rule 70 (list_type -> FLOATLIST .)


state 35

    (71) list_type -> STRINGLIST .

    IDENTIFIER      reduce using rule 71 (list_type -> STRINGLIST .)


state 36

    (72) list_type -> DOUBLELIST .

    IDENTIFIER      reduce using rule 72 (list_type -> DOUBLELIST .)


state 37

    (65) array_type -> INTARRAY .

    IDENTIFIER      reduce using rule 65 (array_type -> INTARRAY .)


state 38

    (66) array_type -> FLOATARRAY .

    IDENTIFIER      reduce using rule 66 (array_type -> FLOATARRAY .)


state 39

    (67) array_type -> STRINGARRAY .

    IDENTIFIER      reduce using rule 67 (array_type -> STRINGARRAY .)


state 40

    (68) array_type -> DOUBLEARRAY .

    IDENTIFIER      reduce using rule 68 (array_type -> DOUBLEARRAY .)


state 41

    (29) if_stmt -> IF . LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 72


state 42

    (31) for_stmt -> FOR . LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 73


state 43

    (32) while_stmt -> WHILE . LPAREN expression RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 74


state 44

    (33) switch_stmt -> SWITCH . LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE

    LPAREN          shift and go to state 75


state 45

    (45) expression -> NOT . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 76
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 46

    (48) expression -> digit .

    QUESTION        reduce using rule 48 (expression -> digit .)
    PLUS            reduce using rule 48 (expression -> digit .)
    MINUS           reduce using rule 48 (expression -> digit .)
    MULTIPLY        reduce using rule 48 (expression -> digit .)
    DIVIDE          reduce using rule 48 (expression -> digit .)
    MODULUS         reduce using rule 48 (expression -> digit .)
    AND             reduce using rule 48 (expression -> digit .)
    OR              reduce using rule 48 (expression -> digit .)
    RPAREN          reduce using rule 48 (expression -> digit .)
    RBRACKET        reduce using rule 48 (expression -> digit .)
    RBRACE          reduce using rule 48 (expression -> digit .)
    COLON           reduce using rule 48 (expression -> digit .)
    SEMICOLON       reduce using rule 48 (expression -> digit .)


state 47

    (50) expression -> boolean .

    QUESTION        reduce using rule 50 (expression -> boolean .)
    PLUS            reduce using rule 50 (expression -> boolean .)
    MINUS           reduce using rule 50 (expression -> boolean .)
    MULTIPLY        reduce using rule 50 (expression -> boolean .)
    DIVIDE          reduce using rule 50 (expression -> boolean .)
    MODULUS         reduce using rule 50 (expression -> boolean .)
    AND             reduce using rule 50 (expression -> boolean .)
    OR              reduce using rule 50 (expression -> boolean .)
    RPAREN          reduce using rule 50 (expression -> boolean .)
    RBRACKET        reduce using rule 50 (expression -> boolean .)
    RBRACE          reduce using rule 50 (expression -> boolean .)
    COLON           reduce using rule 50 (expression -> boolean .)
    SEMICOLON       reduce using rule 50 (expression -> boolean .)


state 48

    (53) digit -> NUMBER .

    QUESTION        reduce using rule 53 (digit -> NUMBER .)
    PLUS            reduce using rule 53 (digit -> NUMBER .)
    MINUS           reduce using rule 53 (digit -> NUMBER .)
    MULTIPLY        reduce using rule 53 (digit -> NUMBER .)
    DIVIDE          reduce using rule 53 (digit -> NUMBER .)
    MODULUS         reduce using rule 53 (digit -> NUMBER .)
    AND             reduce using rule 53 (digit -> NUMBER .)
    OR              reduce using rule 53 (digit -> NUMBER .)
    RPAREN          reduce using rule 53 (digit -> NUMBER .)
    RBRACKET        reduce using rule 53 (digit -> NUMBER .)
    RBRACE          reduce using rule 53 (digit -> NUMBER .)
    COLON           reduce using rule 53 (digit -> NUMBER .)
    SEMICOLON       reduce using rule 53 (digit -> NUMBER .)


state 49

    (54) boolean -> TRUE .

    QUESTION        reduce using rule 54 (boolean -> TRUE .)
    PLUS            reduce using rule 54 (boolean -> TRUE .)
    MINUS           reduce using rule 54 (boolean -> TRUE .)
    MULTIPLY        reduce using rule 54 (boolean -> TRUE .)
    DIVIDE          reduce using rule 54 (boolean -> TRUE .)
    MODULUS         reduce using rule 54 (boolean -> TRUE .)
    AND             reduce using rule 54 (boolean -> TRUE .)
    OR              reduce using rule 54 (boolean -> TRUE .)
    RPAREN          reduce using rule 54 (boolean -> TRUE .)
    RBRACKET        reduce using rule 54 (boolean -> TRUE .)
    RBRACE          reduce using rule 54 (boolean -> TRUE .)
    COLON           reduce using rule 54 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 54 (boolean -> TRUE .)


state 50

    (55) boolean -> FALSE .

    QUESTION        reduce using rule 55 (boolean -> FALSE .)
    PLUS            reduce using rule 55 (boolean -> FALSE .)
    MINUS           reduce using rule 55 (boolean -> FALSE .)
    MULTIPLY        reduce using rule 55 (boolean -> FALSE .)
    DIVIDE          reduce using rule 55 (boolean -> FALSE .)
    MODULUS         reduce using rule 55 (boolean -> FALSE .)
    AND             reduce using rule 55 (boolean -> FALSE .)
    OR              reduce using rule 55 (boolean -> FALSE .)
    RPAREN          reduce using rule 55 (boolean -> FALSE .)
    RBRACKET        reduce using rule 55 (boolean -> FALSE .)
    RBRACE          reduce using rule 55 (boolean -> FALSE .)
    COLON           reduce using rule 55 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 55 (boolean -> FALSE .)


state 51

    (2) stmt_list -> stmt stmt_list .

    $end            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    RBRACE          reduce using rule 2 (stmt_list -> stmt stmt_list .)
    CASE            reduce using rule 2 (stmt_list -> stmt stmt_list .)
    DEFAULT         reduce using rule 2 (stmt_list -> stmt stmt_list .)


state 52

    (12) class_declaration -> CLASS IDENTIFIER . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 77


state 53

    (51) expression -> IDENTIFIER LBRACKET . expression RBRACKET
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 78
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 54

    (52) expression -> IDENTIFIER LBRACE . expression RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 79
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 55

    (13) fun_declaration -> FUN IDENTIFIER . LPAREN params RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 80


state 56

    (46) expression -> LPAREN expression . RPAREN
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 81
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 57

    (47) expression -> IDENTIFIER .
    (51) expression -> IDENTIFIER . LBRACKET expression RBRACKET
    (52) expression -> IDENTIFIER . LBRACE expression RBRACE

    RPAREN          reduce using rule 47 (expression -> IDENTIFIER .)
    PLUS            reduce using rule 47 (expression -> IDENTIFIER .)
    MINUS           reduce using rule 47 (expression -> IDENTIFIER .)
    MULTIPLY        reduce using rule 47 (expression -> IDENTIFIER .)
    DIVIDE          reduce using rule 47 (expression -> IDENTIFIER .)
    MODULUS         reduce using rule 47 (expression -> IDENTIFIER .)
    AND             reduce using rule 47 (expression -> IDENTIFIER .)
    OR              reduce using rule 47 (expression -> IDENTIFIER .)
    QUESTION        reduce using rule 47 (expression -> IDENTIFIER .)
    RBRACKET        reduce using rule 47 (expression -> IDENTIFIER .)
    RBRACE          reduce using rule 47 (expression -> IDENTIFIER .)
    COLON           reduce using rule 47 (expression -> IDENTIFIER .)
    SEMICOLON       reduce using rule 47 (expression -> IDENTIFIER .)
    LBRACKET        shift and go to state 53
    LBRACE          shift and go to state 54


state 58

    (17) import_declaration -> IMPORT STRING_LITERAL .

    CLASS           reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    FUN             reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    IMPORT          reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    PRINT           reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    INT             reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    FLOAT           reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    DOUBLE          reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    STRING          reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    BOOLEAN         reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    IDENTIFIER      reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    INTLIST         reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    FLOATLIST       reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    STRINGLIST      reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    DOUBLELIST      reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    INTARRAY        reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    FLOATARRAY      reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    STRINGARRAY     reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    DOUBLEARRAY     reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    IF              reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    FOR             reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    WHILE           reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    SWITCH          reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    NOT             reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    LPAREN          reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    STRING_LITERAL  reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    NUMBER          reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    TRUE            reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    FALSE           reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    $end            reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    RBRACE          reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    CASE            reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)
    DEFAULT         reduce using rule 17 (import_declaration -> IMPORT STRING_LITERAL .)


state 59

    (21) assignment -> general_type IDENTIFIER . ASSIGN expression SEMICOLON
    (18) variable_declaration -> general_type IDENTIFIER . SEMICOLON

    ASSIGN          shift and go to state 82
    SEMICOLON       shift and go to state 83


state 60

    (30) if_stmt -> expression QUESTION . expression COLON expression SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 84
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 61

    (38) expression -> expression PLUS . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 85
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 62

    (39) expression -> expression MINUS . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 86
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 63

    (40) expression -> expression MULTIPLY . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 87
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 64

    (41) expression -> expression DIVIDE . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 88
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 65

    (42) expression -> expression MODULUS . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 89
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 66

    (43) expression -> expression AND . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 90
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 67

    (44) expression -> expression OR . expression
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 91
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 68

    (22) assignment -> type IDENTIFIER . LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> type IDENTIFIER . LBRACE expression RBRACE ASSIGN expression SEMICOLON

    LBRACKET        shift and go to state 92
    LBRACE          shift and go to state 93


state 69

    (19) variable_declaration -> list_type IDENTIFIER . LBRACKET RBRACKET SEMICOLON

    LBRACKET        shift and go to state 94


state 70

    (20) variable_declaration -> array_type IDENTIFIER . LBRACE RBRACE SEMICOLON

    LBRACE          shift and go to state 95


state 71

    (24) print_stmt -> PRINT LPAREN . expression RPAREN SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 96
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 72

    (29) if_stmt -> IF LPAREN . expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 97
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 73

    (31) for_stmt -> FOR LPAREN . assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 100
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36

    assignment                     shift and go to state 98
    general_type                   shift and go to state 99
    type                           shift and go to state 20
    array_type                     shift and go to state 101
    list_type                      shift and go to state 102

state 74

    (32) while_stmt -> WHILE LPAREN . expression RPAREN LBRACE stmt_list RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 103
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 75

    (33) switch_stmt -> SWITCH LPAREN . expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 104
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 76

    (45) expression -> NOT expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 45 (expression -> NOT expression .)
    RPAREN          reduce using rule 45 (expression -> NOT expression .)
    RBRACKET        reduce using rule 45 (expression -> NOT expression .)
    RBRACE          reduce using rule 45 (expression -> NOT expression .)
    COLON           reduce using rule 45 (expression -> NOT expression .)
    SEMICOLON       reduce using rule 45 (expression -> NOT expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 45 (expression -> NOT expression .) ]
  ! MINUS           [ reduce using rule 45 (expression -> NOT expression .) ]
  ! MULTIPLY        [ reduce using rule 45 (expression -> NOT expression .) ]
  ! DIVIDE          [ reduce using rule 45 (expression -> NOT expression .) ]
  ! MODULUS         [ reduce using rule 45 (expression -> NOT expression .) ]
  ! AND             [ reduce using rule 45 (expression -> NOT expression .) ]
  ! OR              [ reduce using rule 45 (expression -> NOT expression .) ]


state 77

    (12) class_declaration -> CLASS IDENTIFIER LBRACE . stmt_list RBRACE
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    stmt_list                      shift and go to state 105
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    expression                     shift and go to state 19
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 78

    (51) expression -> IDENTIFIER LBRACKET expression . RBRACKET
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RBRACKET        shift and go to state 106
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 79

    (52) expression -> IDENTIFIER LBRACE expression . RBRACE
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RBRACE          shift and go to state 107
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 80

    (13) fun_declaration -> FUN IDENTIFIER LPAREN . params RPAREN LBRACE stmt_list RBRACE
    (14) params -> . general_type IDENTIFIER COMMA params
    (15) params -> . general_type IDENTIFIER
    (16) params -> . empty
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (73) empty -> .

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 100
    RPAREN          reduce using rule 73 (empty -> .)

    params                         shift and go to state 108
    general_type                   shift and go to state 109
    empty                          shift and go to state 110

state 81

    (46) expression -> LPAREN expression RPAREN .

    QUESTION        reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    MULTIPLY        reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    MODULUS         reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 46 (expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 46 (expression -> LPAREN expression RPAREN .)


state 82

    (21) assignment -> general_type IDENTIFIER ASSIGN . expression SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 111
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 83

    (18) variable_declaration -> general_type IDENTIFIER SEMICOLON .

    CLASS           reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    FUN             reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    IMPORT          reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    INT             reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    BOOLEAN         reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    INTLIST         reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    FLOATLIST       reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    STRINGLIST      reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    DOUBLELIST      reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    INTARRAY        reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    FLOATARRAY      reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    STRINGARRAY     reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    DOUBLEARRAY     reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    IF              reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    SWITCH          reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    LPAREN          reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    STRING_LITERAL  reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    NUMBER          reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    TRUE            reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    FALSE           reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    $end            reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    CASE            reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)
    DEFAULT         reduce using rule 18 (variable_declaration -> general_type IDENTIFIER SEMICOLON .)


state 84

    (30) if_stmt -> expression QUESTION expression . COLON expression SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    COLON           shift and go to state 112
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 85

    (38) expression -> expression PLUS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 38 (expression -> expression PLUS expression .)
    RPAREN          reduce using rule 38 (expression -> expression PLUS expression .)
    RBRACKET        reduce using rule 38 (expression -> expression PLUS expression .)
    RBRACE          reduce using rule 38 (expression -> expression PLUS expression .)
    COLON           reduce using rule 38 (expression -> expression PLUS expression .)
    SEMICOLON       reduce using rule 38 (expression -> expression PLUS expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! MINUS           [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! MULTIPLY        [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! DIVIDE          [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! MODULUS         [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! AND             [ reduce using rule 38 (expression -> expression PLUS expression .) ]
  ! OR              [ reduce using rule 38 (expression -> expression PLUS expression .) ]


state 86

    (39) expression -> expression MINUS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 39 (expression -> expression MINUS expression .)
    RPAREN          reduce using rule 39 (expression -> expression MINUS expression .)
    RBRACKET        reduce using rule 39 (expression -> expression MINUS expression .)
    RBRACE          reduce using rule 39 (expression -> expression MINUS expression .)
    COLON           reduce using rule 39 (expression -> expression MINUS expression .)
    SEMICOLON       reduce using rule 39 (expression -> expression MINUS expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! MINUS           [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! MULTIPLY        [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! DIVIDE          [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! MODULUS         [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! AND             [ reduce using rule 39 (expression -> expression MINUS expression .) ]
  ! OR              [ reduce using rule 39 (expression -> expression MINUS expression .) ]


state 87

    (40) expression -> expression MULTIPLY expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 40 (expression -> expression MULTIPLY expression .)
    RPAREN          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    RBRACKET        reduce using rule 40 (expression -> expression MULTIPLY expression .)
    RBRACE          reduce using rule 40 (expression -> expression MULTIPLY expression .)
    COLON           reduce using rule 40 (expression -> expression MULTIPLY expression .)
    SEMICOLON       reduce using rule 40 (expression -> expression MULTIPLY expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]
  ! MULTIPLY        [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]
  ! DIVIDE          [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]
  ! MODULUS         [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]
  ! AND             [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]
  ! OR              [ reduce using rule 40 (expression -> expression MULTIPLY expression .) ]


state 88

    (41) expression -> expression DIVIDE expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 41 (expression -> expression DIVIDE expression .)
    RPAREN          reduce using rule 41 (expression -> expression DIVIDE expression .)
    RBRACKET        reduce using rule 41 (expression -> expression DIVIDE expression .)
    RBRACE          reduce using rule 41 (expression -> expression DIVIDE expression .)
    COLON           reduce using rule 41 (expression -> expression DIVIDE expression .)
    SEMICOLON       reduce using rule 41 (expression -> expression DIVIDE expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]
  ! MINUS           [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]
  ! MULTIPLY        [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]
  ! DIVIDE          [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]
  ! MODULUS         [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]
  ! AND             [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]
  ! OR              [ reduce using rule 41 (expression -> expression DIVIDE expression .) ]


state 89

    (42) expression -> expression MODULUS expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 42 (expression -> expression MODULUS expression .)
    RPAREN          reduce using rule 42 (expression -> expression MODULUS expression .)
    RBRACKET        reduce using rule 42 (expression -> expression MODULUS expression .)
    RBRACE          reduce using rule 42 (expression -> expression MODULUS expression .)
    COLON           reduce using rule 42 (expression -> expression MODULUS expression .)
    SEMICOLON       reduce using rule 42 (expression -> expression MODULUS expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 42 (expression -> expression MODULUS expression .) ]
  ! MINUS           [ reduce using rule 42 (expression -> expression MODULUS expression .) ]
  ! MULTIPLY        [ reduce using rule 42 (expression -> expression MODULUS expression .) ]
  ! DIVIDE          [ reduce using rule 42 (expression -> expression MODULUS expression .) ]
  ! MODULUS         [ reduce using rule 42 (expression -> expression MODULUS expression .) ]
  ! AND             [ reduce using rule 42 (expression -> expression MODULUS expression .) ]
  ! OR              [ reduce using rule 42 (expression -> expression MODULUS expression .) ]


state 90

    (43) expression -> expression AND expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 43 (expression -> expression AND expression .)
    RPAREN          reduce using rule 43 (expression -> expression AND expression .)
    RBRACKET        reduce using rule 43 (expression -> expression AND expression .)
    RBRACE          reduce using rule 43 (expression -> expression AND expression .)
    COLON           reduce using rule 43 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 43 (expression -> expression AND expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! MULTIPLY        [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! DIVIDE          [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! MODULUS         [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 43 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 43 (expression -> expression AND expression .) ]


state 91

    (44) expression -> expression OR expression .
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    QUESTION        reduce using rule 44 (expression -> expression OR expression .)
    RPAREN          reduce using rule 44 (expression -> expression OR expression .)
    RBRACKET        reduce using rule 44 (expression -> expression OR expression .)
    RBRACE          reduce using rule 44 (expression -> expression OR expression .)
    COLON           reduce using rule 44 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 44 (expression -> expression OR expression .)
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67

  ! PLUS            [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! MULTIPLY        [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! DIVIDE          [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! MODULUS         [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 44 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 44 (expression -> expression OR expression .) ]


state 92

    (22) assignment -> type IDENTIFIER LBRACKET . expression RBRACKET ASSIGN expression SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 113
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 93

    (23) assignment -> type IDENTIFIER LBRACE . expression RBRACE ASSIGN expression SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 114
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 94

    (19) variable_declaration -> list_type IDENTIFIER LBRACKET . RBRACKET SEMICOLON

    RBRACKET        shift and go to state 115


state 95

    (20) variable_declaration -> array_type IDENTIFIER LBRACE . RBRACE SEMICOLON

    RBRACE          shift and go to state 116


state 96

    (24) print_stmt -> PRINT LPAREN expression . RPAREN SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 117
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 97

    (29) if_stmt -> IF LPAREN expression . RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 118
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 98

    (31) for_stmt -> FOR LPAREN assignment . SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE

    SEMICOLON       shift and go to state 119


state 99

    (21) assignment -> general_type . IDENTIFIER ASSIGN expression SEMICOLON
    (56) type -> general_type .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    IDENTIFIER      shift and go to state 120

  ! IDENTIFIER      [ reduce using rule 56 (type -> general_type .) ]


state 100

    (64) general_type -> IDENTIFIER .

    IDENTIFIER      reduce using rule 64 (general_type -> IDENTIFIER .)


state 101

    (57) type -> array_type .

    IDENTIFIER      reduce using rule 57 (type -> array_type .)


state 102

    (58) type -> list_type .

    IDENTIFIER      reduce using rule 58 (type -> list_type .)


state 103

    (32) while_stmt -> WHILE LPAREN expression . RPAREN LBRACE stmt_list RBRACE
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 121
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 104

    (33) switch_stmt -> SWITCH LPAREN expression . RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 122
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 105

    (12) class_declaration -> CLASS IDENTIFIER LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 123


state 106

    (51) expression -> IDENTIFIER LBRACKET expression RBRACKET .

    QUESTION        reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MULTIPLY        reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    MODULUS         reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    AND             reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    OR              reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    RBRACE          reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    COLON           reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 51 (expression -> IDENTIFIER LBRACKET expression RBRACKET .)


state 107

    (52) expression -> IDENTIFIER LBRACE expression RBRACE .

    QUESTION        reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    PLUS            reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    MINUS           reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    MULTIPLY        reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    DIVIDE          reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    MODULUS         reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    AND             reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    OR              reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    RPAREN          reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    RBRACKET        reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    RBRACE          reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    COLON           reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)
    SEMICOLON       reduce using rule 52 (expression -> IDENTIFIER LBRACE expression RBRACE .)


state 108

    (13) fun_declaration -> FUN IDENTIFIER LPAREN params . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 124


state 109

    (14) params -> general_type . IDENTIFIER COMMA params
    (15) params -> general_type . IDENTIFIER

    IDENTIFIER      shift and go to state 125


state 110

    (16) params -> empty .

    RPAREN          reduce using rule 16 (params -> empty .)


state 111

    (21) assignment -> general_type IDENTIFIER ASSIGN expression . SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 126
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 112

    (30) if_stmt -> expression QUESTION expression COLON . expression SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 127
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 113

    (22) assignment -> type IDENTIFIER LBRACKET expression . RBRACKET ASSIGN expression SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RBRACKET        shift and go to state 128
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 114

    (23) assignment -> type IDENTIFIER LBRACE expression . RBRACE ASSIGN expression SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RBRACE          shift and go to state 129
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 115

    (19) variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET . SEMICOLON

    SEMICOLON       shift and go to state 130


state 116

    (20) variable_declaration -> array_type IDENTIFIER LBRACE RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 131


state 117

    (24) print_stmt -> PRINT LPAREN expression RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 132


state 118

    (29) if_stmt -> IF LPAREN expression RPAREN . LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 133


state 119

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON . expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 134
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 120

    (21) assignment -> general_type IDENTIFIER . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 82


state 121

    (32) while_stmt -> WHILE LPAREN expression RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 135


state 122

    (33) switch_stmt -> SWITCH LPAREN expression RPAREN . LBRACE case_stmts default_stmt RBRACE

    LBRACE          shift and go to state 136


state 123

    (12) class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .

    CLASS           reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    FUN             reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    IMPORT          reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    INT             reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    STRING          reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    BOOLEAN         reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    IDENTIFIER      reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    INTLIST         reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    FLOATLIST       reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    STRINGLIST      reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    DOUBLELIST      reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    INTARRAY        reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    FLOATARRAY      reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    STRINGARRAY     reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    DOUBLEARRAY     reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    IF              reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    SWITCH          reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    STRING_LITERAL  reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    NUMBER          reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    TRUE            reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    FALSE           reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    $end            reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    CASE            reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)
    DEFAULT         reduce using rule 12 (class_declaration -> CLASS IDENTIFIER LBRACE stmt_list RBRACE .)


state 124

    (13) fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 137


state 125

    (14) params -> general_type IDENTIFIER . COMMA params
    (15) params -> general_type IDENTIFIER .

    COMMA           shift and go to state 138
    RPAREN          reduce using rule 15 (params -> general_type IDENTIFIER .)


state 126

    (21) assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .

    CLASS           reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    FUN             reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    IMPORT          reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    INT             reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    BOOLEAN         reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTLIST         reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOATLIST       reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRINGLIST      reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLELIST      reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    INTARRAY        reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    FLOATARRAY      reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRINGARRAY     reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    DOUBLEARRAY     reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    IF              reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    SWITCH          reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    NUMBER          reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    $end            reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    CASE            reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    DEFAULT         reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 21 (assignment -> general_type IDENTIFIER ASSIGN expression SEMICOLON .)


state 127

    (30) if_stmt -> expression QUESTION expression COLON expression . SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 139
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 128

    (22) assignment -> type IDENTIFIER LBRACKET expression RBRACKET . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 140


state 129

    (23) assignment -> type IDENTIFIER LBRACE expression RBRACE . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 141


state 130

    (19) variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .

    CLASS           reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    FUN             reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    IMPORT          reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    PRINT           reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    STRING          reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    BOOLEAN         reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    INTLIST         reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    FLOATLIST       reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    STRINGLIST      reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    DOUBLELIST      reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    INTARRAY        reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    FLOATARRAY      reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    STRINGARRAY     reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    DOUBLEARRAY     reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    SWITCH          reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    NOT             reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    LPAREN          reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    STRING_LITERAL  reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    NUMBER          reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    TRUE            reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    FALSE           reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    $end            reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    RBRACE          reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    CASE            reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)
    DEFAULT         reduce using rule 19 (variable_declaration -> list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON .)


state 131

    (20) variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .

    CLASS           reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    FUN             reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    IMPORT          reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    PRINT           reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    INT             reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    FLOAT           reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    STRING          reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    BOOLEAN         reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    IDENTIFIER      reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    INTLIST         reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    FLOATLIST       reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    STRINGLIST      reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    DOUBLELIST      reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    INTARRAY        reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    FLOATARRAY      reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    STRINGARRAY     reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    DOUBLEARRAY     reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    IF              reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    FOR             reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    WHILE           reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    SWITCH          reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    NOT             reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    LPAREN          reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    STRING_LITERAL  reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    NUMBER          reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    TRUE            reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    FALSE           reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    $end            reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    RBRACE          reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    CASE            reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)
    DEFAULT         reduce using rule 20 (variable_declaration -> array_type IDENTIFIER LBRACE RBRACE SEMICOLON .)


state 132

    (24) print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .

    CLASS           reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FUN             reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IMPORT          reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    PRINT           reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INT             reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FLOAT           reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING          reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    BOOLEAN         reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTLIST         reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FLOATLIST       reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRINGLIST      reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLELIST      reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    INTARRAY        reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FLOATARRAY      reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRINGARRAY     reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DOUBLEARRAY     reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    IF              reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FOR             reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    WHILE           reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    SWITCH          reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    NOT             reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    LPAREN          reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    STRING_LITERAL  reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    NUMBER          reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    TRUE            reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    FALSE           reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    $end            reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    RBRACE          reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    CASE            reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)
    DEFAULT         reduce using rule 24 (print_stmt -> PRINT LPAREN expression RPAREN SEMICOLON .)


state 133

    (29) if_stmt -> IF LPAREN expression RPAREN LBRACE . stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    expression                     shift and go to state 19
    stmt_list                      shift and go to state 142
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 134

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON expression . SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 143
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 135

    (32) while_stmt -> WHILE LPAREN expression RPAREN LBRACE . stmt_list RBRACE
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    expression                     shift and go to state 19
    stmt_list                      shift and go to state 144
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 136

    (33) switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE . case_stmts default_stmt RBRACE
    (34) case_stmts -> . CASE expression COLON stmt_list case_stmts
    (35) case_stmts -> . empty
    (73) empty -> .

    CASE            shift and go to state 146
    DEFAULT         reduce using rule 73 (empty -> .)
    RBRACE          reduce using rule 73 (empty -> .)

    case_stmts                     shift and go to state 145
    empty                          shift and go to state 147

state 137

    (13) fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE . stmt_list RBRACE
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    stmt_list                      shift and go to state 148
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    expression                     shift and go to state 19
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 138

    (14) params -> general_type IDENTIFIER COMMA . params
    (14) params -> . general_type IDENTIFIER COMMA params
    (15) params -> . general_type IDENTIFIER
    (16) params -> . empty
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (73) empty -> .

    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 100
    RPAREN          reduce using rule 73 (empty -> .)

    general_type                   shift and go to state 109
    params                         shift and go to state 149
    empty                          shift and go to state 110

state 139

    (30) if_stmt -> expression QUESTION expression COLON expression SEMICOLON .

    CLASS           reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    FUN             reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    IMPORT          reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    PRINT           reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    INT             reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    FLOAT           reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    DOUBLE          reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    STRING          reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    BOOLEAN         reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    IDENTIFIER      reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    INTLIST         reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    FLOATLIST       reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    STRINGLIST      reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    DOUBLELIST      reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    INTARRAY        reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    FLOATARRAY      reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    STRINGARRAY     reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    DOUBLEARRAY     reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    IF              reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    FOR             reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    WHILE           reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    SWITCH          reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    NOT             reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    LPAREN          reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    NUMBER          reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    TRUE            reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    FALSE           reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    $end            reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    RBRACE          reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    CASE            reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)
    DEFAULT         reduce using rule 30 (if_stmt -> expression QUESTION expression COLON expression SEMICOLON .)


state 140

    (22) assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN . expression SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 150
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 141

    (23) assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN . expression SEMICOLON
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 151
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 142

    (29) if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list . RBRACE ELSE LBRACE stmt_list RBRACE

    RBRACE          shift and go to state 152


state 143

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON . expression RPAREN LBRACE stmt_list RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 153
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 144

    (32) while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 154


state 145

    (33) switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts . default_stmt RBRACE
    (36) default_stmt -> . DEFAULT COLON stmt_list
    (37) default_stmt -> . empty
    (73) empty -> .

    DEFAULT         shift and go to state 156
    RBRACE          reduce using rule 73 (empty -> .)

    default_stmt                   shift and go to state 155
    empty                          shift and go to state 157

state 146

    (34) case_stmts -> CASE . expression COLON stmt_list case_stmts
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    IDENTIFIER      shift and go to state 57
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    expression                     shift and go to state 158
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 147

    (35) case_stmts -> empty .

    DEFAULT         reduce using rule 35 (case_stmts -> empty .)
    RBRACE          reduce using rule 35 (case_stmts -> empty .)


state 148

    (13) fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 159


state 149

    (14) params -> general_type IDENTIFIER COMMA params .

    RPAREN          reduce using rule 14 (params -> general_type IDENTIFIER COMMA params .)


state 150

    (22) assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression . SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 160
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 151

    (23) assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression . SEMICOLON
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    SEMICOLON       shift and go to state 161
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 152

    (29) if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE . ELSE LBRACE stmt_list RBRACE

    ELSE            shift and go to state 162


state 153

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression . RPAREN LBRACE stmt_list RBRACE
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    RPAREN          shift and go to state 163
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 154

    (32) while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .

    CLASS           reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    FUN             reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    IMPORT          reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    STRING          reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    BOOLEAN         reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    IDENTIFIER      reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    INTLIST         reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    FLOATLIST       reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    STRINGLIST      reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    DOUBLELIST      reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    INTARRAY        reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    FLOATARRAY      reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    STRINGARRAY     reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    DOUBLEARRAY     reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    SWITCH          reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    STRING_LITERAL  reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    NUMBER          reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    TRUE            reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    FALSE           reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    $end            reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    CASE            reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)
    DEFAULT         reduce using rule 32 (while_stmt -> WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE .)


state 155

    (33) switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt . RBRACE

    RBRACE          shift and go to state 164


state 156

    (36) default_stmt -> DEFAULT . COLON stmt_list

    COLON           shift and go to state 165


state 157

    (37) default_stmt -> empty .

    RBRACE          reduce using rule 37 (default_stmt -> empty .)


state 158

    (34) case_stmts -> CASE expression . COLON stmt_list case_stmts
    (38) expression -> expression . PLUS expression
    (39) expression -> expression . MINUS expression
    (40) expression -> expression . MULTIPLY expression
    (41) expression -> expression . DIVIDE expression
    (42) expression -> expression . MODULUS expression
    (43) expression -> expression . AND expression
    (44) expression -> expression . OR expression

    COLON           shift and go to state 166
    PLUS            shift and go to state 61
    MINUS           shift and go to state 62
    MULTIPLY        shift and go to state 63
    DIVIDE          shift and go to state 64
    MODULUS         shift and go to state 65
    AND             shift and go to state 66
    OR              shift and go to state 67


state 159

    (13) fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .

    CLASS           reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    FUN             reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    IMPORT          reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    STRING          reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    BOOLEAN         reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    IDENTIFIER      reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    INTLIST         reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    FLOATLIST       reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    STRINGLIST      reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    DOUBLELIST      reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    INTARRAY        reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    FLOATARRAY      reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    STRINGARRAY     reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    DOUBLEARRAY     reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    SWITCH          reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    STRING_LITERAL  reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    NUMBER          reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    TRUE            reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    FALSE           reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    $end            reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    CASE            reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)
    DEFAULT         reduce using rule 13 (fun_declaration -> FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE .)


state 160

    (22) assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .

    CLASS           reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    FUN             reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    IMPORT          reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    INT             reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    BOOLEAN         reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    INTLIST         reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    FLOATLIST       reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    STRINGLIST      reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    DOUBLELIST      reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    INTARRAY        reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    FLOATARRAY      reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    STRINGARRAY     reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    DOUBLEARRAY     reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    IF              reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    SWITCH          reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    NUMBER          reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    $end            reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    CASE            reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    DEFAULT         reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 22 (assignment -> type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON .)


state 161

    (23) assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .

    CLASS           reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    FUN             reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    IMPORT          reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    PRINT           reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    INT             reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    FLOAT           reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    DOUBLE          reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    STRING          reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    BOOLEAN         reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    INTLIST         reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    FLOATLIST       reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    STRINGLIST      reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    DOUBLELIST      reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    INTARRAY        reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    FLOATARRAY      reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    STRINGARRAY     reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    DOUBLEARRAY     reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    IF              reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    SWITCH          reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    NOT             reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    LPAREN          reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    NUMBER          reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    TRUE            reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    FALSE           reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    $end            reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    RBRACE          reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    CASE            reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    DEFAULT         reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)
    SEMICOLON       reduce using rule 23 (assignment -> type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON .)


state 162

    (29) if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 167


state 163

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 168


state 164

    (33) switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .

    CLASS           reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    FUN             reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    IMPORT          reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    PRINT           reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    INT             reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    FLOAT           reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    DOUBLE          reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    STRING          reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    BOOLEAN         reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    IDENTIFIER      reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    INTLIST         reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    FLOATLIST       reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    STRINGLIST      reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    DOUBLELIST      reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    INTARRAY        reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    FLOATARRAY      reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    STRINGARRAY     reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    DOUBLEARRAY     reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    IF              reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    FOR             reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    WHILE           reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    SWITCH          reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    NOT             reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    LPAREN          reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    STRING_LITERAL  reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    NUMBER          reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    TRUE            reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    FALSE           reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    $end            reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    RBRACE          reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    CASE            reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)
    DEFAULT         reduce using rule 33 (switch_stmt -> SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE .)


state 165

    (36) default_stmt -> DEFAULT COLON . stmt_list
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    stmt_list                      shift and go to state 169
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    expression                     shift and go to state 19
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 166

    (34) case_stmts -> CASE expression COLON . stmt_list case_stmts
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    CASE            reduce using rule 73 (empty -> .)
    DEFAULT         reduce using rule 73 (empty -> .)
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    expression                     shift and go to state 19
    stmt_list                      shift and go to state 170
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 167

    (29) if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE . stmt_list RBRACE
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    expression                     shift and go to state 19
    stmt_list                      shift and go to state 171
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    assignment                     shift and go to state 8
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 168

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE . stmt_list RBRACE
    (2) stmt_list -> . stmt stmt_list
    (3) stmt_list -> . empty
    (4) stmt -> . class_declaration
    (5) stmt -> . fun_declaration
    (6) stmt -> . import_declaration
    (7) stmt -> . assignment
    (8) stmt -> . variable_declaration
    (9) stmt -> . print_stmt
    (10) stmt -> . control_structure
    (11) stmt -> . empty
    (73) empty -> .
    (12) class_declaration -> . CLASS IDENTIFIER LBRACE stmt_list RBRACE
    (13) fun_declaration -> . FUN IDENTIFIER LPAREN params RPAREN LBRACE stmt_list RBRACE
    (17) import_declaration -> . IMPORT STRING_LITERAL
    (21) assignment -> . general_type IDENTIFIER ASSIGN expression SEMICOLON
    (22) assignment -> . type IDENTIFIER LBRACKET expression RBRACKET ASSIGN expression SEMICOLON
    (23) assignment -> . type IDENTIFIER LBRACE expression RBRACE ASSIGN expression SEMICOLON
    (18) variable_declaration -> . general_type IDENTIFIER SEMICOLON
    (19) variable_declaration -> . list_type IDENTIFIER LBRACKET RBRACKET SEMICOLON
    (20) variable_declaration -> . array_type IDENTIFIER LBRACE RBRACE SEMICOLON
    (24) print_stmt -> . PRINT LPAREN expression RPAREN SEMICOLON
    (25) control_structure -> . if_stmt
    (26) control_structure -> . for_stmt
    (27) control_structure -> . while_stmt
    (28) control_structure -> . switch_stmt
    (59) general_type -> . INT
    (60) general_type -> . FLOAT
    (61) general_type -> . DOUBLE
    (62) general_type -> . STRING
    (63) general_type -> . BOOLEAN
    (64) general_type -> . IDENTIFIER
    (56) type -> . general_type
    (57) type -> . array_type
    (58) type -> . list_type
    (69) list_type -> . INTLIST
    (70) list_type -> . FLOATLIST
    (71) list_type -> . STRINGLIST
    (72) list_type -> . DOUBLELIST
    (65) array_type -> . INTARRAY
    (66) array_type -> . FLOATARRAY
    (67) array_type -> . STRINGARRAY
    (68) array_type -> . DOUBLEARRAY
    (29) if_stmt -> . IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE
    (30) if_stmt -> . expression QUESTION expression COLON expression SEMICOLON
    (31) for_stmt -> . FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE
    (32) while_stmt -> . WHILE LPAREN expression RPAREN LBRACE stmt_list RBRACE
    (33) switch_stmt -> . SWITCH LPAREN expression RPAREN LBRACE case_stmts default_stmt RBRACE
    (38) expression -> . expression PLUS expression
    (39) expression -> . expression MINUS expression
    (40) expression -> . expression MULTIPLY expression
    (41) expression -> . expression DIVIDE expression
    (42) expression -> . expression MODULUS expression
    (43) expression -> . expression AND expression
    (44) expression -> . expression OR expression
    (45) expression -> . NOT expression
    (46) expression -> . LPAREN expression RPAREN
    (47) expression -> . IDENTIFIER
    (48) expression -> . digit
    (49) expression -> . STRING_LITERAL
    (50) expression -> . boolean
    (51) expression -> . IDENTIFIER LBRACKET expression RBRACKET
    (52) expression -> . IDENTIFIER LBRACE expression RBRACE
    (53) digit -> . NUMBER
    (54) boolean -> . TRUE
    (55) boolean -> . FALSE

  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for FUN resolved as shift
  ! shift/reduce conflict for IMPORT resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for INTLIST resolved as shift
  ! shift/reduce conflict for FLOATLIST resolved as shift
  ! shift/reduce conflict for STRINGLIST resolved as shift
  ! shift/reduce conflict for DOUBLELIST resolved as shift
  ! shift/reduce conflict for INTARRAY resolved as shift
  ! shift/reduce conflict for FLOATARRAY resolved as shift
  ! shift/reduce conflict for STRINGARRAY resolved as shift
  ! shift/reduce conflict for DOUBLEARRAY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for STRING_LITERAL resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBRACE          reduce using rule 73 (empty -> .)
    CLASS           shift and go to state 12
    FUN             shift and go to state 14
    IMPORT          shift and go to state 16
    PRINT           shift and go to state 23
    INT             shift and go to state 28
    FLOAT           shift and go to state 29
    DOUBLE          shift and go to state 30
    STRING          shift and go to state 31
    BOOLEAN         shift and go to state 32
    IDENTIFIER      shift and go to state 13
    INTLIST         shift and go to state 33
    FLOATLIST       shift and go to state 34
    STRINGLIST      shift and go to state 35
    DOUBLELIST      shift and go to state 36
    INTARRAY        shift and go to state 37
    FLOATARRAY      shift and go to state 38
    STRINGARRAY     shift and go to state 39
    DOUBLEARRAY     shift and go to state 40
    IF              shift and go to state 41
    FOR             shift and go to state 42
    WHILE           shift and go to state 43
    SWITCH          shift and go to state 44
    NOT             shift and go to state 45
    LPAREN          shift and go to state 15
    STRING_LITERAL  shift and go to state 17
    NUMBER          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

  ! CLASS           [ reduce using rule 73 (empty -> .) ]
  ! FUN             [ reduce using rule 73 (empty -> .) ]
  ! IMPORT          [ reduce using rule 73 (empty -> .) ]
  ! PRINT           [ reduce using rule 73 (empty -> .) ]
  ! INT             [ reduce using rule 73 (empty -> .) ]
  ! FLOAT           [ reduce using rule 73 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 73 (empty -> .) ]
  ! STRING          [ reduce using rule 73 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 73 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 73 (empty -> .) ]
  ! INTLIST         [ reduce using rule 73 (empty -> .) ]
  ! FLOATLIST       [ reduce using rule 73 (empty -> .) ]
  ! STRINGLIST      [ reduce using rule 73 (empty -> .) ]
  ! DOUBLELIST      [ reduce using rule 73 (empty -> .) ]
  ! INTARRAY        [ reduce using rule 73 (empty -> .) ]
  ! FLOATARRAY      [ reduce using rule 73 (empty -> .) ]
  ! STRINGARRAY     [ reduce using rule 73 (empty -> .) ]
  ! DOUBLEARRAY     [ reduce using rule 73 (empty -> .) ]
  ! IF              [ reduce using rule 73 (empty -> .) ]
  ! FOR             [ reduce using rule 73 (empty -> .) ]
  ! WHILE           [ reduce using rule 73 (empty -> .) ]
  ! SWITCH          [ reduce using rule 73 (empty -> .) ]
  ! NOT             [ reduce using rule 73 (empty -> .) ]
  ! LPAREN          [ reduce using rule 73 (empty -> .) ]
  ! STRING_LITERAL  [ reduce using rule 73 (empty -> .) ]
  ! NUMBER          [ reduce using rule 73 (empty -> .) ]
  ! TRUE            [ reduce using rule 73 (empty -> .) ]
  ! FALSE           [ reduce using rule 73 (empty -> .) ]

    assignment                     shift and go to state 8
    expression                     shift and go to state 19
    stmt_list                      shift and go to state 172
    stmt                           shift and go to state 3
    empty                          shift and go to state 4
    class_declaration              shift and go to state 5
    fun_declaration                shift and go to state 6
    import_declaration             shift and go to state 7
    variable_declaration           shift and go to state 9
    print_stmt                     shift and go to state 10
    control_structure              shift and go to state 11
    general_type                   shift and go to state 18
    type                           shift and go to state 20
    list_type                      shift and go to state 21
    array_type                     shift and go to state 22
    if_stmt                        shift and go to state 24
    for_stmt                       shift and go to state 25
    while_stmt                     shift and go to state 26
    switch_stmt                    shift and go to state 27
    digit                          shift and go to state 46
    boolean                        shift and go to state 47

state 169

    (36) default_stmt -> DEFAULT COLON stmt_list .

    RBRACE          reduce using rule 36 (default_stmt -> DEFAULT COLON stmt_list .)


state 170

    (34) case_stmts -> CASE expression COLON stmt_list . case_stmts
    (34) case_stmts -> . CASE expression COLON stmt_list case_stmts
    (35) case_stmts -> . empty
    (73) empty -> .

    CASE            shift and go to state 146
    DEFAULT         reduce using rule 73 (empty -> .)
    RBRACE          reduce using rule 73 (empty -> .)

    case_stmts                     shift and go to state 173
    empty                          shift and go to state 147

state 171

    (29) if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 174


state 172

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list . RBRACE

    RBRACE          shift and go to state 175


state 173

    (34) case_stmts -> CASE expression COLON stmt_list case_stmts .

    DEFAULT         reduce using rule 34 (case_stmts -> CASE expression COLON stmt_list case_stmts .)
    RBRACE          reduce using rule 34 (case_stmts -> CASE expression COLON stmt_list case_stmts .)


state 174

    (29) if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .

    CLASS           reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    FUN             reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    IMPORT          reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    INT             reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    STRING          reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    BOOLEAN         reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    IDENTIFIER      reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    INTLIST         reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    FLOATLIST       reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    STRINGLIST      reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    DOUBLELIST      reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    INTARRAY        reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    FLOATARRAY      reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    STRINGARRAY     reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    DOUBLEARRAY     reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    IF              reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    SWITCH          reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    STRING_LITERAL  reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    NUMBER          reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    TRUE            reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    FALSE           reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    $end            reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    CASE            reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)
    DEFAULT         reduce using rule 29 (if_stmt -> IF LPAREN expression RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE .)


state 175

    (31) for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .

    CLASS           reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    FUN             reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    IMPORT          reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    PRINT           reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    STRING          reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    BOOLEAN         reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    IDENTIFIER      reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    INTLIST         reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    FLOATLIST       reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    STRINGLIST      reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    DOUBLELIST      reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    INTARRAY        reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    FLOATARRAY      reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    STRINGARRAY     reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    DOUBLEARRAY     reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    SWITCH          reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    LPAREN          reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    STRING_LITERAL  reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    NUMBER          reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    TRUE            reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    FALSE           reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    $end            reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    CASE            reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)
    DEFAULT         reduce using rule 31 (for_stmt -> FOR LPAREN assignment SEMICOLON expression SEMICOLON expression RPAREN LBRACE stmt_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for CLASS in state 0 resolved as shift
WARNING: shift/reduce conflict for FUN in state 0 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 0 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 0 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 0 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 0 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 0 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 0 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for NOT in state 0 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 0 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 0 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 0 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 0 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 3 resolved as shift
WARNING: shift/reduce conflict for FUN in state 3 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for INT in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 3 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 3 resolved as shift
WARNING: shift/reduce conflict for STRING in state 3 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 3 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 3 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 3 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 3 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 3 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 3 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 3 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 3 resolved as shift
WARNING: shift/reduce conflict for NOT in state 3 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 3 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 3 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 3 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 3 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 3 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 18 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 21 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 22 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 76 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 76 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 76 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 76 resolved as shift
WARNING: shift/reduce conflict for AND in state 76 resolved as shift
WARNING: shift/reduce conflict for OR in state 76 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 77 resolved as shift
WARNING: shift/reduce conflict for FUN in state 77 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 77 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 77 resolved as shift
WARNING: shift/reduce conflict for INT in state 77 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 77 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 77 resolved as shift
WARNING: shift/reduce conflict for STRING in state 77 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 77 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 77 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 77 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 77 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 77 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 77 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 77 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 77 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 77 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 77 resolved as shift
WARNING: shift/reduce conflict for IF in state 77 resolved as shift
WARNING: shift/reduce conflict for FOR in state 77 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 77 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 77 resolved as shift
WARNING: shift/reduce conflict for NOT in state 77 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 77 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 77 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 77 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 77 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 85 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 85 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 85 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 85 resolved as shift
WARNING: shift/reduce conflict for AND in state 85 resolved as shift
WARNING: shift/reduce conflict for OR in state 85 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 86 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 86 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 86 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 86 resolved as shift
WARNING: shift/reduce conflict for AND in state 86 resolved as shift
WARNING: shift/reduce conflict for OR in state 86 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 87 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 87 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 87 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 87 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 87 resolved as shift
WARNING: shift/reduce conflict for AND in state 87 resolved as shift
WARNING: shift/reduce conflict for OR in state 87 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 88 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 88 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 88 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 88 resolved as shift
WARNING: shift/reduce conflict for AND in state 88 resolved as shift
WARNING: shift/reduce conflict for OR in state 88 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 89 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 89 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 89 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 89 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 89 resolved as shift
WARNING: shift/reduce conflict for AND in state 89 resolved as shift
WARNING: shift/reduce conflict for OR in state 89 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 90 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 90 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 90 resolved as shift
WARNING: shift/reduce conflict for AND in state 90 resolved as shift
WARNING: shift/reduce conflict for OR in state 90 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 91 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 91 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 91 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 91 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 91 resolved as shift
WARNING: shift/reduce conflict for AND in state 91 resolved as shift
WARNING: shift/reduce conflict for OR in state 91 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 99 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 133 resolved as shift
WARNING: shift/reduce conflict for FUN in state 133 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 133 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 133 resolved as shift
WARNING: shift/reduce conflict for INT in state 133 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 133 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 133 resolved as shift
WARNING: shift/reduce conflict for STRING in state 133 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 133 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 133 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 133 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 133 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 133 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 133 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 133 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 133 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 133 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 133 resolved as shift
WARNING: shift/reduce conflict for IF in state 133 resolved as shift
WARNING: shift/reduce conflict for FOR in state 133 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 133 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 133 resolved as shift
WARNING: shift/reduce conflict for NOT in state 133 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 133 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 133 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 133 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 133 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 133 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 135 resolved as shift
WARNING: shift/reduce conflict for FUN in state 135 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 135 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 135 resolved as shift
WARNING: shift/reduce conflict for INT in state 135 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 135 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 135 resolved as shift
WARNING: shift/reduce conflict for STRING in state 135 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 135 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 135 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 135 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 135 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 135 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 135 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 135 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 135 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 135 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 135 resolved as shift
WARNING: shift/reduce conflict for IF in state 135 resolved as shift
WARNING: shift/reduce conflict for FOR in state 135 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 135 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 135 resolved as shift
WARNING: shift/reduce conflict for NOT in state 135 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 135 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 135 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 135 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 135 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 135 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 137 resolved as shift
WARNING: shift/reduce conflict for FUN in state 137 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 137 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 137 resolved as shift
WARNING: shift/reduce conflict for INT in state 137 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 137 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 137 resolved as shift
WARNING: shift/reduce conflict for STRING in state 137 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 137 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 137 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 137 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 137 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 137 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 137 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 137 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 137 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 137 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 137 resolved as shift
WARNING: shift/reduce conflict for IF in state 137 resolved as shift
WARNING: shift/reduce conflict for FOR in state 137 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 137 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 137 resolved as shift
WARNING: shift/reduce conflict for NOT in state 137 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 137 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 137 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 137 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 137 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 137 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 165 resolved as shift
WARNING: shift/reduce conflict for FUN in state 165 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 165 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 165 resolved as shift
WARNING: shift/reduce conflict for INT in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 165 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 165 resolved as shift
WARNING: shift/reduce conflict for STRING in state 165 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 165 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 165 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 165 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 165 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 165 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 165 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 165 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 165 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 165 resolved as shift
WARNING: shift/reduce conflict for IF in state 165 resolved as shift
WARNING: shift/reduce conflict for FOR in state 165 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 165 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 165 resolved as shift
WARNING: shift/reduce conflict for NOT in state 165 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 165 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 165 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 165 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 165 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 165 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 166 resolved as shift
WARNING: shift/reduce conflict for FUN in state 166 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 166 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 166 resolved as shift
WARNING: shift/reduce conflict for INT in state 166 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 166 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 166 resolved as shift
WARNING: shift/reduce conflict for STRING in state 166 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 166 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 166 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 166 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 166 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 166 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 166 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 166 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 166 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 166 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 166 resolved as shift
WARNING: shift/reduce conflict for IF in state 166 resolved as shift
WARNING: shift/reduce conflict for FOR in state 166 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 166 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 166 resolved as shift
WARNING: shift/reduce conflict for NOT in state 166 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 166 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 166 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 166 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 166 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 166 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 167 resolved as shift
WARNING: shift/reduce conflict for FUN in state 167 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 167 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 167 resolved as shift
WARNING: shift/reduce conflict for INT in state 167 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 167 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 167 resolved as shift
WARNING: shift/reduce conflict for STRING in state 167 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 167 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 167 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 167 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 167 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 167 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 167 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 167 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 167 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 167 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 167 resolved as shift
WARNING: shift/reduce conflict for IF in state 167 resolved as shift
WARNING: shift/reduce conflict for FOR in state 167 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 167 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 167 resolved as shift
WARNING: shift/reduce conflict for NOT in state 167 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 167 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 167 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 167 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 167 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 167 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 168 resolved as shift
WARNING: shift/reduce conflict for FUN in state 168 resolved as shift
WARNING: shift/reduce conflict for IMPORT in state 168 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 168 resolved as shift
WARNING: shift/reduce conflict for INT in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 168 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 168 resolved as shift
WARNING: shift/reduce conflict for STRING in state 168 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 168 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 168 resolved as shift
WARNING: shift/reduce conflict for INTLIST in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOATLIST in state 168 resolved as shift
WARNING: shift/reduce conflict for STRINGLIST in state 168 resolved as shift
WARNING: shift/reduce conflict for DOUBLELIST in state 168 resolved as shift
WARNING: shift/reduce conflict for INTARRAY in state 168 resolved as shift
WARNING: shift/reduce conflict for FLOATARRAY in state 168 resolved as shift
WARNING: shift/reduce conflict for STRINGARRAY in state 168 resolved as shift
WARNING: shift/reduce conflict for DOUBLEARRAY in state 168 resolved as shift
WARNING: shift/reduce conflict for IF in state 168 resolved as shift
WARNING: shift/reduce conflict for FOR in state 168 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 168 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 168 resolved as shift
WARNING: shift/reduce conflict for NOT in state 168 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 168 resolved as shift
WARNING: shift/reduce conflict for STRING_LITERAL in state 168 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 168 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 168 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 168 resolved as shift
WARNING: reduce/reduce conflict in state 4 resolved using rule (stmt_list -> empty)
WARNING: rejected rule (stmt -> empty) in state 4
